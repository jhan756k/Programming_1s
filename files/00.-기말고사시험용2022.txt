 
T/F로 답하시오.

**************************************************************************************************************************************************

[chapter 1 ]

* JAVA프로그래밍 언어를 만들고 배포하는 컴퓨터 회사는 SUN 사이다.

* JAVA를 이용하여 프로그래밍을 하고자 하는 경우에는 JRE를 다운로드 받아서 설치하면 된다.

* 자바를 설치한 폴더와는 다른 폴더에서 자바 프로그래밍을 하고 명령 프롬프트를 이용하여 컴파일하고 실행하기 위해서는 PATH라는 환경변수를 설정하여야 한다.

* 자바 소스파일의 확장자는 class이다.

* JAVA로 프로그래밍 할 때 class의 이름과 소스파일의 이름은 같아야 하지만 대소문자까지 같을 필요는 없다.

* 자바 소스 파일을 컴파일 하기위하여 사용되는 실행 파일은 javac.exe이다.

* 자바 소스 파일을 컴파일하여 성공하면 그 결과로 확장자가 class인 파일이 생성된다.

* 확장자가 class인 파일을 실행하기 위하여 사용하는 실행 파일은 java.exe 이다.

* Hello.class라는 파일을 명령형 프롬프트에서 실행하기 위하여 명령을 내린다면 java.exe Hello.class 라고 입력해야 한다.


[chapter 2 변수]

* 자바의 변수타입(Data Type)은 크게 기본 자료형(Primitive Data Type)과 참조 자료형(Reference Data Type)이 있다.

* 자바의 기본 자료형(Primitive Data Type)에는 문자형, 논리형, 숫자형이 있다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 숫자형은 정수형과 실수형이 있다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 문자형은 char 키워드를 이용한다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 논리형은 bool 키워드를 이용한다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 정수형은 int, long 의 두 가지이다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 실수형은 byte, short, float, double의 네 가지이다.

* JAVA의 실수형 데이터형은 float, double이 있다.

* JAVA에서 변수란 값을 저장하는 공간이고 한번에 여러 개의 값을 저장시킬 수 있다.

* JAVA에서 2바이트를 사용하는 기본데이터 형으로는 short와 float가 있다.

* JAVA에서 가장 많은 바이트를 사용하는 기본데이터형은 long형과 double형이다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 논리형에 사용가능한 리터럴은 true, false 두 가지이다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 정수형 중에서 기본형은 long형이다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 실수형 중에서 기본형은 float형이다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 4bytes를 사용하는 데이터형은 char와 long과 float 세 가지이다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 int형에 입력가능한 숫자의 범위는 -2^15 - +2^15 까지이다.

* 자바에서 정수형 데이터를 저장하기 위해서 사용하는 방식을 부호와 절대값 법이라고 한다.

* 자바의 데이터형 중에서 byte형은 -128 ～ +127사이의 숫자를 저장할 수 있다.

* 자바에서 실수를 저장하기 위해서는 고정 소수점 표현방법을 이용한다.

* 자바에서 double형 데이터를 표현하기 위하여 부호 1비트, 지수 8비트, 가수 23비트로 표현한다.

* 자바에서 실수를 표현할 때 표현하려는 수를 이진화한 후 일정한 형태로 변화시키는데 이 과정을 표준화(standardize)라고 한다.

* 자바에서 실수를 표현할 때 그 수가 양수인 경우 부호 비트는 1로 나타난다.

* 자바의 기본 자료형(Primitive Data Type) 중에서 실수형들은 실제 숫자의 저장을 위하여 IEEE 754법이라는 방법을 사용한다.

* 자바의 기본 자료형(Primitive Data Type) 중 실수형인 float형은 실수 하나를 저장하기 위하여 1(부호)+8(지수)+23(가수) 형태로 총 32bit를 이용한다.

* 자바의 프로그래밍시 사용하는 단어 중에서 이미 의미가 확정되어 있는 단어를 식별자(Identifier), 프로그래머가 직접 명명하는 단어를 키워드(Keyword)라고 한다.

* 프로그래밍시 변수의 이름을 지을때 반드시 숫자로 시작해야 하며 8자이내로 지어야 한다.

* 프로그래밍시 변수의 이름중에는 어떤 형태의 특수문자도 허용되지 않는다.

* 자바에서 각 데이터 형에 매칭되는 리터럴을 구별하기 위하여 접미사들을 쓰기도 하는데 접미사 d는 long을 위하여, f는 double형을 위하여 사용한다.

* 자바에서 변수 초기화란 선언된 변수가 사용가능해지는 최초시점에 값을 주는 것을 말한다. 기본 자료형은 선언시점에 바로 초기화를 위한 값을 줄 수 있고 특별히 초기화 해주지 않으면 자동 초기화 된다.

* JAVA에서 상수를 선언 하고자 하는 경우 선언문의 앞쪽에 constant라는 예약어를 덧붙인다.

* 'A', '\u0041', '\t' 등의 리터럴은 모두 char형 리터럴이다.

* 자바에서 정수형 리터럴을 만들기 위해서는 반드시 10진법만이 사용되어야 한다.

* 자바에서 long형 리터럴을 만들기 위해서는 정수형 숫자 뒤에 D또는 d의 접미사를 붙여야 한다.

* 자바에서 3.14f 또는 3.14F와 같은 리터럴은 float형 리터럴인데 이 경우 접미사 f와 F를 생략하여도 float형 리터럴이 된다.

* 10. 같은 수는 소수 부분이 없으므로 정수형 리터럴이다.

* 자바의 변수이름은 대소문자를 구별하지 않는다.

* 자바의 변수이름을 예약어를 사용하여 지어도 무방하다.

* 자바의 변수이름에는 어떠한 경우라도 숫자가 포함되어서는 안 된다.

* 자바에서 정수연산을 하는 경우 그 수가 데이터형의 표현범위를 넘어서는 경우 컴퓨터가 멈추고 그 결과 값은 예측할 수 없게 된다.

* 자바의 정수형은 각각 저장할 수 있는 값들의 범위가 정해져 있는데 그 값의 범위를 넘는 값들이 들어가야 하는 경우 발생하는 수치 오류 현상을 형변환(Type Casting)이라고 한다.

* 자바 프로그래밍시 한 수식내에 서로 종류가 다른 데이터 형이 혼재하는 경우 연산을 가능하게 하기 위하여 일시적으로 형을 변화시켜 연산을 가능하게 하는 현상을 Overflow라고 한다.

* 자바에서 사용되는 Cast 연산자는 [data-type] 형태이다.

[chapter 3 연산자]

* 자바에서 프로그래밍시에 데이터들의 계산을 유발시키는 기호를 연산자(Operator)라고 하고 연산의 대상이 되는 데이터를 피연산자(Operand)라고 한다.

* 연산자의 작업 대상은 변수, 상수, 리터럴, 수식 등이 있다.

* 연산자를 산술연산자, 비교연산자, 논리연산자 등으로 분류한 경우 분류기준은 기능에 따른 분류이다.

* 연산자 중에서 피연산자를 두 개 가지는 연산자를 이항 연산자라고 하며 종류가 가장 많다.

* 자바의 연산자를 분류하는 방법중에서 피연산자의 갯수를 기준으로 분류하면 단항 연산자, 이항 연산자, 삼항 연산자로 분류할 수 있다.

* 자바의 연산자중에서 수학에서 사칙 연산같은 연산을 해내는 연산자들을 산술연산자라고 한다.

* 자바의 연산자중에서 연산의 결과가 boolean형으로 나오는 연산자는 비교(관계) 연산자와 비트 연산자가 있다.

* 연산자 중에서 모든 단항연산자는 항상 피연산자의 앞쪽에 위치하게 된다.

* 연산자가 여러 개 포함된 수식에서 어떤 연산자가 먼저 계산되어야 하는 가에 관련된 규칙을 연산자의 결합방향이라고 한다.

* 연산자가 여러 개 포함된 수식에서 동일한 연산자가 여러 개 존재하면 항상 맨 왼쪽의 연산자부터 계산이 이루어진다.

* 산술연산자는 논리연산자보다 먼저 계산된다.

* 비교연산자는 논리연산자보다 먼저 계산된다.

* 기능상으로 동일한 연산자 군에 속하는 연산자들은 항상 우선순위가 동일하다.

* 산술연산자 중에서 % 연산자는 나눗셈의 몫을 구해주는 기능을 한다.

* 연산자중에서 정수데이터의 비트가 직접적인 연산의 대상이 되는 연산자는 비트 논리 연산자와 시프트 연산자가 있다.

* 이항연산자는 연산 전에 피연산자의 형(type)을 항상 일치시킨다.

* 연산자중 피연산자를 세 개 가지는 연산자를 삼항 연산자라고 하며 Java에서는 여러 개 존재한다.

* 자바에서 대입연산자와 비교연산자 중 같다라는 의미를 가지는 연산자는 동일한 기호를 사용하고 문맥에 의해서만 구별된다.

* 대입연산자의 왼쪽에 위치하는 피연산자는 변수형태여야 한다.

* 하나의 수식에서 종류가 다른 여러 개의 연산자가 동시에 존재하는 경우 어느 연산자가 먼저 작용하는가에 관한 규칙을 연산자의 연산방향이라고 한다.

* 하나의 수식에서 같은 여러 개의 연산자가 동시에 존재하는 경우 어느 연산자가 먼저 작용하는가에 관한 규칙을 연산자의 우선순위라고 한다.

* 단항 연산자는 모두 다 전위형(prefix)으로도 후위형(postfix)으로도 사용될 수 있다.

 (권기영) 논리연산자는 피연산자도 boolean형이고 연산의 결과도 boolean 형이다. ( T / F )

 (이원재) 증가, 감소연산자는 단순한 수식이나 복잡한 수식에서 모두 동일한 우선순위를 가진다. ( T / F )

 (김정현) Math.round() 메소드는 double형 숫자를 소수점 첫째자리에서 반올림하여 정수 값을 반환한다. ( T / F )

 (이준엽) ^ 연산자는 거듭제곱을 해주는 산술연산자이다. ( T / F )

 (이재상) 3<<1+2 의 결과는 24이다. ( T / F )

 (권해찬) shift-left 연산자는 두 개 존재한다. ( T / F )

 (안태규) bit연산자 &가 이진 연산을 할 때 결과가 0이 나올 가능성은 3/4 이다. ( T / F )

 (서영환) 2<x<10 과 x>2&&x<10 두 수식은 동일한 결과 값을 내는 수식이다. ( T / F )

 (김유경) 이항연산자의 피연산자들 중 int보다 크기가 작은 형인 boolean, char, byte, short형은 이항연산자를 사용한 수식에서 모두 int형으로 형변환되어 연산이 진행된다. ( T / F )

 (이도엽) 33<<1 과 33<<33의 결과 값은 동일하다. ( T / F )

 (임동규) 5=i; 는 가능하지만 5==i; 는 에러가나는 문장이다. ( T / F )

 (배상규) x>=3&&x<=9 와 (x>=3)&&(x<=9) 는 동일한 결과를 내는 수식이다. ( T / F )

 (오지석) byte a=127; byte b=1; System.out.println(a+b); 의 실행 결과는 -128이다. ( T / F )

 (우종윤) boolean 리터럴도 산술연산자의 피연산자가 될 수 있다. ( T / F )


 (박종윤) shift-left 연산자는 * 연산자 보다,  shift-right 연산자는 / 연산자보다 수행 속도도 빠르고 우선순위도 높다. ( T / F )

 (남가민) ~ 연산자의 피연산자는 정수형이며, 연산 결과 값은 원래 피연산자의 부호가 그대로 유지된다. ( T / F )


[chapter 4 조건문과 반복문]

* 프로그래밍을 위하여 사용되는 3대 제어구조는 순차, 반복(루프), 선택(분기)이다.

* 선택(분기)의 제어 구조를 만들기 위해 주로 사용되는 키워드는 if 와 switch-case 이다.

*  반복(루프)의 제어구조를 만들기 위하여 주로 사용되는 키워드는 for, while, do-while이 있다.

* 반복의 제어구조를 이용하여 지정된 반복횟수만큼 반복이 일어나고 있는 동안에는 어떠한 경우라도 중간에 탈출할 수 없다.

* for라는 키워드를 사용할 때 초기 값을 지정하는 부분은 전체 반복 횟수 중에서 한번만 실행된다.

* Java에서 모든 제어들은 독립적으로 사용되며 서로 겹치거나 중첩될 수 없다.

* 자바에서 조건문을 만들기위한 키워드로는 if 구문, 또는 if-else 구문, if-else if-else구문 그리고  switch-case구문이 있다.

* if-else if-else구문과 switch-case 구문은 다중 선택을 위한 조건문을 만들기 위한 구문이기 때문에 어떠한 조건 형태라도 완벽하게 호환된다.

* Math.random()이라는 메소드는 한번 호출시마다 0.0 < x < 1.0 사이에 위치하는 임의의 x 값을 만들어 낸다.

* Math.random()은 0.0이상 1.0미만의 임의의 double형 숫자를 만들어 낸다.

* 자바에서 반복을 얻기 위한 키워드는 for, while, do-while 구문이 있다.

* 자바의 반복문중에서 반복의 횟수가 명확한 형태의 반복문을 만들기 위하여 주로 사용하는 키워드는 for이다.

* for의 사용시에 초기값, 조건식, 증감식은 하나라도 생략될수 없다.

* 반복문내의 문장은 또 다른 반복문일 수 없다.

* 중첩루프에서 바깥쪽 루프를 외부루프, 안쪽 루프를 내부루프라 부르고, 외부루프의 조건에 따라 내부루프의 실행횟수가 영향을 받는 경우 종속 중첩루프라고 한다.

* while은 문법적으로 조건식만을 적을 수 있기 때문에 카운팅이 가능한 루프는 만들수 없다.

* 반복문으로 문장을 반복시킨 경우 반복의 횟수가 만족되기 전까지는 절대로 루프를 탈출하는 것이 불가능하다.

 (박성우) for나 while 모두 조건식을 생략하여 무한반복을 만들 수 있다. ( T / F )

 (조신영) switch-case에서 default는 항상 모든 case 이후에 나타날 수 있다. ( T / F )

 (박지수) 제어구조 중 순차는 특별한 키워드를 사용하지 않고도 만들 수 있다. ( T / F )

 (조성현) switch-case에서 일치하는 case가 없고, default도 생략된 경우에는 에러가 발생한다. ( T / F )

 (김창환) + 연산자가 prefix 라면 부호 연산자인 경우이다. ( T / F )

 (김창환) switch-case 내부에서 if를 중첩할 수 없다. ( T / F )


[chapter 5 배열]

* 자바의 참조 자료형 중에서 동일 테이터형의 집합적인 데이터를 표현하기 위하여 사용하는 것은 클래스이다.

* 배열은 기본 자료형과 같이 선언이후 바로 값을 저장할수 있다.

* 배열 선언시에 사용하는 배열 기호는 반드시 선언하는 데이터형 뒤에 변수의 앞에만 나와야 한다.

* 자바에서 참조형 자료의 정의를 위하여 사용되는 키워드는 new이다.

* 배열을 위한 변수가 선언되고 정의되면 배열의 이름은 실제 변수값이 저장되는 공간의 시작 주소와 관련된 정보를 저장한다.

* 자바에서 배열 이름을 참조해서 얻어지는 데이터 저장 공간의 시작 인덱스는 1부터 시작된다.

* 배열이 선언 정의되고나면 배열 원소들은 기본 자료형과 동일하게 자동 초기화되지 않는다.

* 배열의 선언과 정의를 한 문장에서 할 수 있다.

* 배열의 선언과 정의 초기화를 한 문장에서 할 경우에도 반드시 배열의 크기를 정하는 숫자는 생략하면 안된다.

* 배열의 초기화를 이용하면 정의하는 문장을 생략할 수도 있다.

* 배열의 크기를 저장하는 상수는 배열이 선언, 정의되면 자동으로 생성되며 그 이름은 배열명.length이고 크기는 정의할때 적은 숫자 -1이다.

***


* 배열을 원소로 가지는 배열을 선언, 정의하는 것이 가능하다. 

* 이차원 배열은 모든 행의 열의 갯수가 반드시 동일하게만 만들 수 있다.

* 기존의 배열과 크기도 같고 들어있는 값도 동일한 배열을 만드는 행위를 shallow copy라고 한다.

* 배열을 어떤 메소드의 인자로 넘기거나 리턴받으려 할때는 반드시 deep copy를 이용하여야 한다.


[chapter 6 객체지향 프로그래밍1]

* 객체 지향 언어의 시초가 되는 언어는 자바이며 1980년대에 개발되었다.

*** 객체 지향 언어의 시초가 되는 언어는 Simula이며 1960년대에 개발되었다.

*** 객체 지향 언어는 절차 지향 언어(명령형 언어)의 한계를 극복하기 위하여 노력을 하였다.

*** 객체지향언어는 기존의 명령형 언어에 비하여 코드를 관리하고 재사용하기 어렵다.

*** 객체 지향 언어는 절차 지향 언어에 비하여 코드의 재사용성을 높이긴 하였지만 신뢰성이 높은 프로 그램을 개발하기는 훨씬 더 어렵다.

* 자바에서 직접 제공되지않는 다양한 데이터는 구조체를 이용하여 직접 설계 제작하여야 한다.

* 클래스를 설계할때 설계하려는 대상의 속성과 기능을 추출하여 속성은 멤버메소드로, 기능은 멤버변수로 만든다.

* 클래스 인스턴스를 가리키는 참조변수는 반드시 하나여야만 한다.

* 멤버 변수는 크게 인스턴스 변수와 클래스 변수로 구분할수 있다.

* 멤버 변수중 클래스 변수는 모든 인스턴스들이 독립적으로 저장 공간을 할당받으므로 각 인스턴스들 마다 다른 값이 저장될 수 있다.

* 인스턴스 변수와 클래스 변수, 지역 변수중에서 가장 오래동안 메모리에 존재 가능한 변수는 클래스 변수이다.

* 클래스 변수나 클래스 메소드는 반드시 참조 변수를 통해서만 호출되거나 접근될 수 있다.

* 클래스 변수가 어떤 참조 변수에 의해 접근되어 값이 변하면 다른 참조변수에 의하여 접근하여도 변화된 값이 적용된다.

* 클래스 메소드는 인스턴스 변수를 내부에서 참조할 수 있지만 사용하는 것이 권장되지는 않는다.

* 인스턴스 메소드는 클래스 변수를 내부에서 참조할 수 있지만 사용되는 것이 권장 되지는 않는다.

* 자바에서 메모리 영역은 Method Area, Stack Area, Heap Area로 구분될 수 있다.

*** 클래스 인스턴스는 Method Area에 메모리를 할당 받는다.

*** 리턴값이 없는 메소드라 할지라도 반드시 return 문을 사용하여야 한다.

* 한 클래스내에서는 동일한 이름을 가진 멤버 변수가 두개 이상 동시에 존재할 수 없다.

* 한 클래스내에서는 동일한 이름을 가진 메소드나 생성자가 두개 이상 동시에 존재할 수 없다.

*** 클래스 설계시 설계자가 생성자를 직접 구현하지 않는다면 클래스를 이용하는 사용자는 클래스 인스턴스를 만들 수 없다.

* 클래스 설계시 설계자가 생성자를 제공하지 않는다면 자바가 기본 생성자를 알아서 제공한다.

* 생성자도 메소드와 기본적으로 동일한 개념이므로 리턴값이 존재할 수 있다.

*** 생성자가 여러개 존재하는 클래스에서 생성자간의 상호 호출은 불가능하다.

* 생성자 중에서 현재 존재하는 인스턴스의 상황과 완전하게 동일한 인스턴스를 만들기 위하여 사용되는 생성자를 복사생성자(Copy Constructor)라고 한다.

* 클래스 인스턴스는 선언, 정의되고 나면 기본값으로 자동 초기화된다.

* 클래스 멤버 변수는 자동 초기화, 명시적 초기화, 생성자에서의 초기화, 블럭초기화 루틴이용한 초기화의 순서대로 초기화 된다.

* (윤성훈) 모든 생성자가 private 속성을 가지더라도 클래스 인스턴스를 리턴하는 스태틱한 메소드가 제공되는 클래스라면 인스턴스를 생성할 수 있다.

* (하인주) 생성자는 this()를 이용하여 오버로딩된 다른 생성자를 호출하는 것은 가능하지만, 생성자 이외의 다른 인스턴스 메소드를 호출하는 것은 불가능하다.

* (하인주) 클래스의 인스턴스 멤버변수를 클래스 자기 자신의 인스턴스를 이용하여 만드는 것은 불가능하다.

* (박형주) 생성자에서 인스턴스를 만들기위해 메모리를 확보하는 문장은 클래스 개발자가 직접 생성자 내부에 기술하여야 한다.

* (박형주) Encapsulation은 클래스 사용자의 편의를 위해 클래스의 내부 구현 정보를 최대한 공개하는 것을 의미한다.

* (김택수) 어떤 참조변수에 의해 실제로 접근이 가능하던 메모리 공간이 어떤 참조 변수에 의해서도 더 이상 접근이 불가능하게 되었을때 이 메모리 공간을 Trash라고 한다.

* (심무경) 클래스의 내부 구현시 항상 멤버 변수를 생성자나 메소드 보다 먼저 기술하여야 한다.

* (손호준) Math 클래스가 인스턴스를 생성할 수 없는 이유는 Math클래스 제작자가 생성자를 아예 만들지 않았기 때문이다.

* (장상원) 멤버변수와 생성자, 메소드는 모두 접근 제어자와 기타제어자를 가질 수 있다.

* (정승원) 생성자가 this()를 이용하여 오버로딩된 다른 생성자를 호출하는 경우 그 생성자는 this() 호출을 제외한 어떤한 문장도 더 적을 수 없다.

* (정승원) 생성자에서는 static한 멤버 변수를 접근하는 것이 불가능 하다.

* (김나영) 생성자는 리턴하는 값이 없으므로 리턴타입이 항상 void 형이라 볼 수 있다.

* (손재윤) 생성자와 동일한 이름을 가진 메소드를 오버로딩의 조건만 만족된다면 만들 수 있다. <= 당위성에 대해 생각해 볼 것

* (김근영) Math클래스의 메소드를 사용하기 위해서는 반드시 Math 클래스의 인스턴스 변수가 필요하다.

* (박재환) 오버로딩 되어있는 메소드를 같은 이름의 다른 메소드에서 선언(호출로 바꾸면) 하는 경우 에러가 발생한다. <= 재환이에게 설명 요구, => 시도해 보니 가능

* (박재환) 클래스 인스턴스는 배열 인스턴스와는 달리 Shallow Copy가 불가능하다. 

* (홍지훈) 인스턴스 메소드에서도 this()를 이용하여 생성자를 호출하는 것이 가능하다.

* (홍지훈) 인스턴스 변수를 선언만 하더라도 스태틱 초기화 블럭에 의한 초기화는 수행된다.

* (한지유) 오버로딩에 관여하는 시그니처는 전달인자의 데이터 타입, 갯수, 순서, 변수 이름과 리턴 타입등이 있다.

* (한예주) 클래스 사용자가 클래스 제작자의 클래스 인스턴스를 사용하는 프로그램을 만기 위해서는 반드시 클래스 제작자의 소스파일이 필요하다.

* (한예주) 메소드만이 아니라 멤버 변수도 오버로딩이 가능하다.

* (곽동준) javadoc을 이용하여 만들어진 메뉴얼 페이지에서 Field Summary부분이 보이지 않는다면 그 클래스는 멤버 변수가 존재하지 않는 클래스이다.

**

* (최보윤) 한 클래스 내에 메소드 또는 생성자가 동일한 이름을 가진채 전달인자의 이름만 다르게 여러개 만들수 있고 이 현상을 overloading이라고 한다.

* (손휘승) 인스턴스 초기화 블럭은 인스턴스 변수 선언시 먼저 한번 동작하고 그 이후 인스턴스 생성시 마다 호출된다.

* (손휘승) 생성자를 만들때 인자가 없는 기본 생성자는 자바가 항상 기본적으로 제공하므로 그것을 제외하고 나머지 필용한 생성자를 만들어 제공하면 된다.

* (오지오) 최초의 OOP 개념을 지원하는 프로그래밍 언어는 java이다.

* (오지오) javadoc을 이용하며 만들어진 메뉴얼 페이지에서 private한 멤버 변수는 Field Summary파트에서 보이지 않치만 private한 메소드는 Method Summary에 보인다.

* (문호현) 클래스 인스턴스 생성시 이루어 지는 초기화는 순서적으로 보면 스태틱 멤버 변수의 자동 초기화 - 스태틱 멤버 변수의 명시적 초기화 - 스태틱 초기화 블럭 - 인스턴스 멤버 변수의 자동 초기화 - 인스턴스 멤버 변수의 명시적 초기화 - 인스턴스 초기화 블럭 - 생성자 순서로 이루어 진다.

* (황철순) 

* (강건) 

* (박재호) this()를 이용하여 두 생성자간에 상호 호출을 하거나, 오버로딩된 메소드가 서로 상호 호출을 하는 코드를 작성하더라도 컴파일은 성공한다.

* (정상민) 어떤 클래스의 인스턴스 멤버변수가 배열이면서도 선언만 이루어진 경우라면, 클래스 인스턴스를 선언, 정의하는 문장만으로는 인스턴스 변수 배열을 위한 메모리 공간확보는 자동적으로 이루어지지 않는다.

* (한예지) Encapsulation을 위해 private 처리된 멤버변수가 있다면 그 변수의 입출력을 위해여 준비한 메소드도 private처리하여야 사용자의 오남용을 막을수 있는 완벽한 Encapsulation이 된다.


**************************************************************************************************************************************************

정의 하시오.

* 참조 자료형으로써의 클래스란 무엇인가?

* Information hiding은 무엇인가?

* Encapsulation은 무엇인가?

* 접근제어자 4가지는 무엇인가?

* 생성자와 메소드의 차이점을 모두 적으시오.

* 생성자중에서 기본생성자는 무엇이며 형태는 어떠한가?

* 생성자의 접근 제어자를 private로 해도 문제가 없으려면 클래스가 어떤 조건을 갖추어야 하는가?

*** Overloading은 무엇이며 Overloading로 얻을 수 있는 장점은 무엇인가?

* 인스턴스 this.는 무엇이며 어떤 경우에 사용되는가?

* 생성자 this()는 무엇이며 사용할 경우 어떤 장점이 있는가?

*** 클래스 인스턴스가 초기화되는 순서는 무엇인가?


**************************************************************************************************************************************************

[chapter 7 객체지향 프로그래밍2]

*** 상속을 위하여 사용되는 키워드는 implements 이다.

*** 상속을 하면 부모 클래스의 모든 요소를 상속 받는다.

*** 클래스 상속시에 자식 클래스는 부모 클래스에서 상속받고자 하는 요소를 선택적으로 지정할 수 있다.

*** 자식 클래스의 멈버 변수나 메소드의 갯수는 부모 클래스의 멤버 변수보다 적어도 같거나 더 많다.

*** 일단 상속이 일어나고 나면 부모 클래스의 내부적인 변화가 생겨도 자식 클래스에 영향을 끼치지 않는다.

*** 자식 클래스는 하나의 부모 클래스만을 가진다.

*** 부모 클래스는 하나의 자식 클래스만을 가진다.

*** 새로운 클래스의 멤버 변수가 다른 클래스의 인스턴스일 경우에 그 인스턴스를 통해 모든 public 메소드를 호출하여 이용할 수 있으므로 상속이라 부를수 있다.

*** 부모클래스로 부터 상속된 메소드가 존재하는 경우 자식 클래스는 그 메소드와 이름이 동일한 메소드를 만들수 없다.

*** 부모클래스로 부터 상속된 메소드가 존재하는 경우 자식 클래스는 그 메소드와 이름은 동일하고 signature가 다른 메소드를 만들수 있다.

*** 부모클래스로 부터 상속된 메소드가 존재하는 경우 자식 클래스는 그 메소드와 이름도 동일하고 signature도 동일한 메소드를 만들수 있다.

*** 오버라이딩(Overriding)되고 난 후에는 자식 클래스에서는 부모 클래스에서 상속된 메소드를 사용할 수 없다.

*** 자식 클래스의 모든 생성자는 첫 줄에 부모클래스의 인자없는 생성자를 호출하는 코드가 존재한다.

*** this.멤버변수와 super.멤버변수는 항상 다른 변수이다.

*** 기본형 자료형과는 달리 참조 자료형은 기본적으로 상호간의 형변환이 불가능하다.

*** 비록 상속 관계에 있다하여도 부모의 참조변수가 자식의 인스턴스를 가리키거나, 또는 자식의 참조 변수가 부모의 인스턴스를 가리키게 되는 형변환이 필요한 문장은 에러가 난다.

*** 부모의 참조 변수에 자식의 인스턴스를 가리키는 형변환은 Up-casting이라 하고 묵시적인 형변환으로 충분히 수행될 수 있다.

*** 자식의 참조 변수에 부모의 인스턴스를 가리키는 형변환은 Down-casting이라 하고 묵시적인 형변환으로 충분히 수행될 수 있다.

*** instanceof


**** 중복선언된 멤버 변수와 참조 변수의 연결

**** 중복선언된 메소드(오버라이드된)와 참조 변수의 연결

**** 오버로딩도 다형성의 일종이다.

**** 매개변수 다형성

**** 컨테이너 클래스 중 Vector class

*** 7-3





**************************************************************************************************************************************************

정의 하시오.

*** 상속(Inheritance)이란 무엇인가?

*** 포함(Composition)이란 무엇인가?

*** 오버라이딩(Overriding)이란 무엇인가?

*** 오버라이딩(Overriding)의 필요성에 대하여 설명하시오.

*** 오버라이딩(Overriding)의 조건을 모두 적으시오.

*** 클래스를 설계할때 인자없는 생성자를 제공하는것이 중요한 이유를 설명하시오.

*** OOP관점에서 볼때 Polymorphism이란 무엇인가?

*** Java 프로그래밍 언어에서 Polymorphism은 어떤 방법으로 얻을 수 있는가?

**** Polymorphism중 매개변수 Polymorphism이란 무엇인가?
