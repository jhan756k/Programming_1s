public class finals {
    public static void main(String[] args) {
        /*
        접근제어자 --> 접근의 권한을 세분화
        private --> 같은 클래스 내에서만 접근 가능
        public --> 모든 클래스에서 접근 가능
        protected --> 상속 관계에서만 접근 가능
        생략 --> 같은 패키지 내에서만 접근 가능 (폴더)

        static method 새로 인스턴스 만들 필요 없이 classname.method() 하면 됨
        static method는 static 키워드만 바꿔서는 오버로딩 안됨

        생성자 없앨 수 있는 조건: 모든 멤버변수가 static일때

        오버로딩된 생성자

        지역변수와 전역변수의 이름이 같을 때 지역변수가 우선시됨
        this.변수명 --> 전역변수를 가리킴

        public May17(){
            May17(1.0); --> 파라미터가 존재하나 재귀호출마냥 되서 에러뜸
            따라서 this 키워드 사용 this() --> 현재 클래스의 모든 생성자를 의미
            this(1.0); // --> 에러없이 완료 출력됨
        }
        public May17(double r){
            System.out.println("완료" + r);
        }

        자동, 명시적, 인스턴스 블럭 루틴, 생성자 순서로 초기화
        
        인스턴스 초기화 블록 --> 객체 생성시 생성자보다 먼저 실행 
        따라서 여러 생성자에서 공통으로 필요한 코드 반복 줄일 수 있음
        인스턴스 블럭 초기화 루틴은 인스턴스 뿐만 아니라 static 변수도 초기화할 수 있다. 
        하지만 static 변수는 static 블럭에서 초기화하는 것이 좋다.

        static 블럭은 static한 요소만 초기화 가능
        static 블럭 초기화 루틴은 클래스가 로딩될 때 실행된다.
        하지만 여러번 실행되지 않는다. (클래스가 로딩될 때 한번만 실행)

        인스턴스 블럭은 인스턴스가 생성될 때마다 실행된다.

        javadoc 위해 public class

        자식 생성자에서 super()는 보이지 않게 호출되는데, 이는 자식 생성자의 첫 줄에
        super()가 자동으로 추가되기 때문이다.

        그래서 부모가 매개변수가 없는 생성자를 제공하지 않는다면 자식 생성자에서
        오류가 뜬다. 이때는 자식 생성자에서 명시적으로 super(매개변수)를 이용하여 부모 생성자를
        사용해야 한다.

        Inheritance vs Composition
        상속은 기존 클래스를 물려받는것
        합성은 기존 클래스의 인스턴스를 새로운 클래스의 멤버 변수로 만드는 경우
        A is B
        A has B

        instanceof 연산자: 참조변수가 참조하는 인스턴스의 실제 타입을 알아보기 위해 사용

        클래스의 부모 쪽으로 갈수록 추상성이 높아지고, 자식 쪽으로 갈수록 구체적이다.

        abstract class --> 추상 클래스 (무조건 부모 클래스를 상속받아야 함 아니면 에러)
        */
    }
}
